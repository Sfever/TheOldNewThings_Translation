# 在自己代码里写"#pragma pack(1)"的人大概也会有一件T恤，上书：我恨RISC

当你写下`#pragma pack(1)`的时候，它将默认的结构体对齐方式更改为字节对齐，移除了所有对齐字节。

考虑以下两个结构体：

```Cpp
// 没有#pragma pack.
struct S
{
    int32_t total;
    int32_t a, b;
};

#pragma pack(1)

struct P
{
    int32_t total;
    int32_t a, b;
};
```

由于内部的成员都已经对齐，两个结构体的布局是完全一致的。你也会认为这两个结构体是等价的。

**但事实不是这样的**

改变结构体的对齐方式还有另一个副作用：他改变了结构体本身的对齐要求。在这个例子里，`#pragma pack(1)`让结构体可以放置在任意地址上，而不是在一个已经对齐的地址上。

考虑以下两个新的结构体：

```Cpp
struct ExtraS
{
    char c;
    S s;
    char d;
};

struct ExtraP
{
    char c;
    P p;
    char d;
};
```

尽管结构体`S`和`P`拥有一样的内存布局，但对齐方式上的不同让`ExtraS`与`ExtraP`变得非常不同。

`ExtraS`结构体以一个`char`类型的变量开头，然后是三个填充字节用来对齐，然后是结构体`S`，然后是另一个`char`和更多的填充字节来确保结构体是正确的4字节对齐。

`ExtraP`的成员与`ExtraS`完全一样，但因为它是字节对齐的，所有的填充字节都被删去。

|  | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0A | 0B | 0C | 0D | 0E | 0F | 10 | 11 | 12 | 13 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| `ExtraS` | `c` | 填充字节| | | `s.total` | | | | `s.a` | | | | `s.b` | | | | `d` | 填充字节 | | |
| `ExtraP` | `c` | `p.total` | | | | `p.a` | | | | `p.b` | | | | `d` |  |  |  |  |  |  |

在一个数组里面差别更加明显：

|  | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0A | 0B | 0C | 0D | 0E | 0F | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 1A | 1B | 1C | 1D | 1E | 1F | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| `ExtraS` | `c` | 填充字节 | | | `s.total` | | | | `s.a` | | | | `s.b` | | | | `d` | 填充字节 | | | `c` | 填充字节 | | | `s.total` | | | | `s.a` | | | | `s.b` | | | | `d` | 填充字节 | | |
| `ExtraP` | `c` | `p.total` | | | | `p.a` | | | | `p.b` | | | | d | `c` | `p.total` | | | | `p.a` | | | | `p.b` | | | | `d` |  |  |  |  |  |  |  |  |  |  |  |  |

可以看到，在`ExtraS`里每一个元素都是4字节对齐的，而`ExtraP`中则没有这样的规律。

任何包含结构体`P`的数据结构都有可能没有正确对齐，这样做导致生成的汇编代码复杂性会显著的提升，因为访问`P`的成员时必须考虑并处理未正确对齐的情况。

考虑以下两个函数：

```Cpp
void UpdateS(S* s)
{
 s->total = s->a + s->b;
}

void UpdateP(P* p)
{
 p->total = p->a + p->b;
}
```

由于对齐方式上的差别，两个函数生成的代码有显著不同：

![](/pragma_pack.md_pics/image.png)

可以看到，对于部分RISC处理器来说，代码量的增加是非常明显的，这可能会影响到函数的内联优化。

总结：除非绝对需要，否则不要使用`#pragma pack(1)`。

Bonus：一旦你使用了它，就不可能再改回去了，移除这个预处理器会让结构体更严格的对齐，对于任何使用单字节对齐的人来说，这是一次breaking change。